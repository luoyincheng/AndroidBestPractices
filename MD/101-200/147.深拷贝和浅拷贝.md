![](C:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\深拷贝vs浅拷贝.png.jpg)

- 对于基本数据类型，对它的拷贝是直接拷贝数值，对于引用数据类型，如果拷贝引用就是浅拷贝，而如果拷贝数据就是深拷贝。
- clone是浅拷贝的，它拷贝的是引用。

### 如何深拷贝？

### `将super.clone()应用到所有对象上。`

参见代码 _147.DeepCopyTest，需要实现Cloneable接口，并在Clone方法中将所有的对象都调用一次super.clone()方法克隆，对于string，如果不调用，new string("***")，那么用“==”判断时候发现内存地址是一样的

```java
protected Person clone() {
	Person person = null;
	try {
		person = (Person) super.clone();
		person.setName(new String(person.getName()));//这行代码加上后用“==”判断内存地址就会不一样
		person.setEmail(new Email(person.getEmail().getContent()));
	} catch (CloneNotSupportedException e) {
		e.printStackTrace();
	}
	return person;
}
```



### `利用序列化实现对象的拷贝`

参见 _147.DeepCopyUtil  

也就是序列化然后反序列化，需要实现Serializable接口，这种方式会将所有的变量都重新拷贝，包括string类型，当用“==”判断string地址是否一样时发现string地址不一样，忽略了字符串常量池的作用？？？？？

