### 结论

- View 的 requestLayout 会回调 onMeasure、onLayout 和 onDraw(ViewGroup.setWillNotDraw(false)的情况下) 方法
- invalidate 只会回调 onDraw 方法
- postInvalidate 只会回调 onDraw 方法(可以在非 UI 线程中回调)

### invalidate()

- invalidate() -> invalidate(boolean invalidateCache)


### ViewRootImpl.performTraversals 中对performMeasure()、performLayout()、performDraw()三个方法的调用

- performMeasure 和 performLayout 限制条件是非常多的，起到决定性作用的是 mLayoutRequested 这个 Flag
- 
- performMeasure 执行后会将 layoutRequested 变更为 true, 不出意外的话, performLayout 会紧接着执行, 都重新测量了, 显然要重新进行控件摆放
- performDraw(); 的执行不受 mLayoutRequested 的影响, 这可能是 invalidate 只会执行 onDraw() 的原因


