### 核心线程池和最大线程池有什么用？
###　假设线程池最大容量为10,核心线程数为5，任务队列为2，第一个任务来了放哪里，第六个任务来了放哪里，第八个任务来了放哪里？



### 为什么需要线程池？

**资源占用** **响应速度** **可管理性**  **易用性**  **创建和销毁** **内存占用** **内存抖动**  **更快的创建** **复用性** 

- 线程的创建和销毁都需要时间，当有大量的线程创建和销毁时，那么这些时间的消耗则比较明显，将导致性能上的缺失
- 大量的线程创建、执行和销毁是非常耗cpu和内存的，这样将直接影响系统的吞吐量，导致性能急剧下降，如果内存资源占用的比较多，还很可能造成OOM
- 大量的线程的创建和销毁很容易导致GC频繁的执行，从而发生内存抖动现象，而发生了内存抖动，对于移动端来说，最大的影响就是造成界面卡顿
- 线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销
- 线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量
- 在执行大量异步任务时提高了性能
- Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等

---

### 类之间的关系

- Executor 

  ```java
  public interface Executor {
      void execute(Runnable command);
  }
  ```

- ExecutorService
  
  ```java
  public interface ExecutorService extends Executor 
  ```
  
- AbstractExecutorService

  ```java
  public abstract class AbstractExecutorService implements ExecutorService 
  ```

- ThreadPoolExecutor

  ```java
  public class ThreadPoolExecutor extends AbstractExecutorService 
  ```

- Executors

  ```java
  /**
   * Factory and utility methods for {@link Executor}, {@link
   * ExecutorService}, {@link ScheduledExecutorService}, {@link
   * ThreadFactory}, and {@link Callable} classes defined in this
   * package. This class supports the following kinds of methods:
   *
   * <ul>
   *   <li>Methods that create and return an {@link ExecutorService}
   *       set up with commonly useful configuration settings.
   *   <li>Methods that create and return a {@link ScheduledExecutorService}
   *       set up with commonly useful configuration settings.
   *   <li>Methods that create and return a "wrapped" ExecutorService, that
   *       disables reconfiguration by making implementation-specific methods
   *       inaccessible.
   *   <li>Methods that create and return a {@link ThreadFactory}
   *       that sets newly created threads to a known state.
   *   <li>Methods that create and return a {@link Callable}
   *       out of other closure-like forms, so they can be used
   *       in execution methods requiring {@code Callable}.
   * </ul>
   *
   * @since 1.5
   * @author Doug Lea
   */
  public class Executors {
      public static ExecutorService newFixedThreadPool(int nThreads) {
          return new ThreadPoolExecutor(nThreads, nThreads,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>());
      }
      ...
      public static ExecutorService newCachedThreadPool() {
          return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                        60L, TimeUnit.SECONDS,
                                        new SynchronousQueue<Runnable>());
      }
      ...
  ```

---

### 参数说明

- `corePoolSize`：线程池的基本线程数。这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了 prestartAllCoreThreads()或者 prestartCoreThread()方法，从这 2 个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建 corePoolSize 个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为 0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到 corePoolSize 后，就会把到达的任务放到缓存队列当中。

- `maximumPoolSize`：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。

- `keepAliveTime`：线程活动保持时间。线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。

- unit：参数 keepAliveTime 的时间单位，有 7 种取值。可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。

- `workQueue`：任务队列。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。

- - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
  - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按 FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue。静态工厂方法 Executors.newFixedThreadPool()使用了这个队列。
  - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。
  - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。

- `threadFactory`：创建线程的工厂。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。

- `handler`：饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是 AbortPolicy，表示无法处理新任务时抛出异常。以下是 JDK1.5 提供的四种策略。

- - AbortPolicy：直接抛出异常。
  - CallerRunsPolicy：只用调用者所在线程来运行任务。
  - DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。
  - DiscardPolicy：不处理，丢弃掉。
  - 当然也可以根据应用场景需要来实现 RejectedExecutionHandler 接口自定义策略。如记录日志或持久化不能处理的任务。

---

### 重要方法

在 ThreadPoolExecutor 类中有几个非常重要的方法：

- `execute()` 方法实际上是 Executor 中声明的方法，在 ThreadPoolExecutor 进行了具体的实现，这个方法是 ThreadPoolExecutor 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。
- `submit()` 方法是在 ExecutorService 中声明的方法，在 AbstractExecutorService 就已经有了具体的实现，在 ThreadPoolExecutor 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 execute()方法不同，它能够返回任务执行的结果，去看 submit()方法的实现，会发现它实际上还是调用的 execute()方法，只不过它利用了 Future 来获取任务执行结果（Future 相关内容将在下一篇讲述）。
- `shutdown()` 和 `shutdownNow()` 是用来关闭线程池的。

---

### 线程池的关闭

我们可以通过调用线程池的 `shutdown` 或 `shutdownNow` 方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow 首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 shutdown 只是将线程池的状态设置成 SHUTDOWN 状态，然后中断所有没有正在执行任务的线程。

只要调用了这两个关闭方法的其中一个，isShutdown 方法就会返回 true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用 isTerminaed 方法会返回 true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 shutdown 来关闭线程池，如果任务不一定要执行完，则可以调用 shutdownNow。

---

### 启动策略

**corePoolSize  -> 队列  -> maxmumPoolSize**

- 线程池刚创建的时候没有一个线程。任务队列是作为参数传进来的。不过，就算任务队列中有任务，线程池也不会马上执行它们。
- 当调用execute()方法添加一个任务时，线程池会做以下判断：
  - 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务。
  - 如果正在运行的线程数量大于或者等于corePoolSize，那么就将这个任务放入队列。
  - 如果这个时候队列满了，而且正在运行的线程数量小于maxmumPoolSize，那么创建新的线程运行这个任务。
  - 如果队列满了，而且正在运行的线程数量大于或者等于maxmumPoolSize,那么该任务将被拒绝策略拒绝（四种拒绝策略，参见下方）。
- 当一个线程完成任务时，它会从队列中取下一个任务来执行。
- 当一个线程无事可做，超过一定的时间(keepAliveTime)时，线程池会判断，如果当前运行的线程数量大于corePoolSize，那么这个线程就被停掉。**`所以线程池的所有任务完成后，他最终会收缩到corePoolSize的大小。`**

---

### 任务拒绝策略

当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略

- ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出 RejectedExecutionException 异常。
- ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
- ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务

---

### 自带的实现

- **`newCachedThreadPool`**

  创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

  这种类型的线程池特点是：

  - 工作线程的创建数量几乎没有限制（其实也有限制的,数目为 Interger.MAX_VALUE）, 这样可灵活的往线程池中添加线程。
  - 如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。
  - 在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有可能造成系统瘫痪。

- **`newFixedThreadPool`**

  创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。

  FixedThreadPool 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

- **`newSingleThreadExecutor`**

  创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。
  
- **` newScheduledThreadPool `**

  创建一个定长线程池，支持定时及周期性任务执行。

  ScheduledExecutorService比Timer更安全，功能更强大

https://zhuanlan.zhihu.com/p/62132884