**Android只能通过Handler更新界面，所有更新界面的方法都只是对Handler的封装而已**

---

### 为什么设计成只能用Handler来更新界面？

之所以这么设计无非就是因为 Android 中的 View 不是线程安全的。之所以将 View 设计成非线程安全的，是因为：
- 对 View 进行加锁之后会增加控件使用的复杂度
- 加锁之后会降低控件执行的效率
- 上锁后会阻塞某些进程的执行

---

- Looper和MessageQueue一一对应

- 一个线程只能有一个Looper（这里是使用ThreadLocal来保证的）

  ```java
  private static void prepare(boolean quitAllowed) {
  	if (sThreadLocal.get() != null) {
  		throw new RuntimeException("Only one Looper may be created per thread");
  	}
  	sThreadLocal.set(new Looper(quitAllowed));
  }
  ```

- 一个Looper对象可以对应多个线程，比如主线程的mainLooper，供主线程和所属子线程共同使用

- 一个线程可以有无数个Handler，这些所有的Handler对应的是同一个Looper。因此，为了让每个messageQueue中的每个消息都只能被被发送这个message的Handler来处理（由Handler a 发出的消息也只能由Handler a来处理），message.target就是发送这个message的Handler。

  ```java
  private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
  	msg.target = this;
  	if (mAsynchronous) {
  		msg.setAsynchronous(true);
  	}
  	return queue.enqueueMessage(msg, uptimeMillis);
  }
  ```

  处理消息的时候通过调用获取message的target然后直接调用dispatchMessage(message)来处理。

  ```java
  try {
       msg.target.dispatchMessage(msg);
       dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
  } finally {
       if (traceTag != 0) {
       	Trace.traceEnd(traceTag);
     }
  }
  ```

- Handler在哪个线程创建的，就跟哪个线程的Looper关联，也可以在Handler的构造方法中传入指定的Looper

- 即Handler里会引用当前线程里的特定Looper和MessageQueue。也就是说，多个Handler都可以共享同一Looper和MessageQueue了。当然，这些Handler也就运行在同一个线程里。

---

### Handler

- Handler默认构造方法跟当前线程中的Looper产生关联

  ##### Handler中那个不传入Looper的构造函数是如何获取到Looper的

  ```java
      /**
       * Use the {@link Looper} for the current thread with the specified callback interface
       * and set whether the handler should be asynchronous.
       */  
      public Handler(Callback callback, boolean async) {
          if (FIND_POTENTIAL_LEAKS) {
              final Class<? extends Handler> klass = getClass();
              if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&
                      (klass.getModifiers() & Modifier.STATIC) == 0) {
                  Log.w(TAG, "The following Handler class should be static or leaks might occur: " +
                      klass.getCanonicalName());
              }
          }
  
          mLooper = Looper.myLooper();//获取到该线程的唯一Looper
          if (mLooper == null) {
              throw new RuntimeException(
                  "Can't create handler inside thread " + Thread.currentThread()
                          + " that has not called Looper.prepare()");
          }
          mQueue = mLooper.mQueue;
          mCallback = callback;
          mAsynchronous = async;
      }
  
      /**
       * Return the Looper object associated with the current thread.  Returns
       * null if the calling thread is not associated with a Looper.
       */
      public static @Nullable Looper myLooper() {
          return sThreadLocal.get();
      }
  ```

- Handler的构造函数中可以设置发送的消息是同步执行还是异步执行

  ```java
  private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
      msg.target = this;
      if (mAsynchronous) {//如果在构造函数中设置为异步的，那么该Handler发送到MessageQueue的Message都将异步执行
          msg.setAsynchronous(true);
      }
      return queue.enqueueMessage(msg, uptimeMillis);
  }
  ```

- Handler.obtainMessage()和Message.obtain()的区别？

  Handler.obtainMessage实际上调用的是Message中的`obtain(Handler h){}`

  ```java
  public static Message obtain(Handler h) {
      Message m = obtain();
      m.target = h;
      return m;
  }
  ```

  而Message.obtain则是调用的只是`obtain{}`

  ```java
  public static Message obtain() {
      synchronized (sPoolSync) {
          if (sPool != null) {
              Message m = sPool;
              sPool = m.next;
              m.next = null;
              m.flags = 0; // clear in-use flag
              sPoolSize--;
              return m;
          }
      }
      return new Message();
  }
  ```

  就是说在Handler中的obtainMessage()方法比Message中的obtain()方法一步：

  给获取到的Message设置target为当前的Handler。

---

### Looper

```java
new Thread() {
		public void run() {
				Looper.prepare();
				mHandlerTest1 = new HandlerTest1(Looper.myLooper());
				Message message = new Message();
				message.obj = "子线程发送的消息Hi~Hi";
				mHandlerTest1.sendMessage(message);
				Looper.loop();
		}
}.start();
```



- 无论是主线程还是其它线程，其中的Looper都只能被实例化一次
- 创建Looper.prepare()会创建一个messageQueue。

### Looper.prepare()的实际作用

- 为当前线程准备消息队列
- 调用Looper.prepare()其实就是利用ThreadLocal为当前的线程创建了一个独立的Looper，这其中包含了一个消息队列。

### Looper.quit()

方法是通过控制停止往MessageQueue中发送消息来实现的，而不是停止执行已经在MessageQueue中的消息。



---

### Looper.loop

- Looper.myLooper()

  ```java
  static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
  
   private static void prepare(boolean quitAllowed) {
      if (sThreadLocal.get() != null) {
          throw new RuntimeException("Only one Looper may be created per thread");
      }
      sThreadLocal.set(new Looper(quitAllowed));
  }
  ```

  

- Looper.loop()开启循环取消息

- 

---

### MessageQueue

- 无论是Message还是Runnable最终都会被封装成Message然后调用sendMessageAtTime()方法将Message加入到MessageQueue中去，在加入之前给每个Message设置对应的Handler: 

  ```java
  msg.target = this;//this是Handler
  ```

---

### Message

##### 同步消息和异步消息

- 同步消息就是在消息队列中的消息是顺次执行，第一个执行完成以后才能只行第二个，以此类推。对吗？
- 异步消息就是消息可以同时执行，消息之间不用等待。对吗？



---

### Looper里面的无限循环return以后，什么时候重新开始循环？

https://juejin.im/post/5bdec872e51d4551ee2761cb　该文章最后