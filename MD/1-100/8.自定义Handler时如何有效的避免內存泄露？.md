<h2 style="text-align:center">自定义Handler时如何有效的避免內存泄露</h2>
### 为什么Handler会内存泄露?

- 在`Java`中，非静态的内部类和匿名内部类都会隐式的持有一个外部类的引用。`MessageQueue`会引用`Message`，`Message`会引用`Handler`，`Handler`会引用`Activity`。而静态内部类是不会持有外部类的实例的。
- 当 `Activity` 调用 finish 方法时，如果消息队列中有没被执行完的 Message，由于`Message` 持有 `Handler` 的引用，而`Handler` 作为内部类又持有外部 Activity 的引用，这就导致Activity无法被回收，如果消息队列中的所有的Message在调用finish方法前都已经处理了，那么就不会内存泄露。
- 内存泄漏的根本原因是一个生命周期长的对象持有一个生命周期短的对象，导致生命周期短的对象无法释放。因此即使`Handler`不是`static`的，但是如果MessageQueue中所有任务都已经被处理了，那么`Handler`的生命周期和`Activity`一样。因此非`static Handler` 内部类并不会导致`Activity`内存泄漏。内存泄漏是因为 handler 有延迟任务，导致 handler 的生命周期比 activity 长。所以才会泄漏。

---

### 解决办法

当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用（不然你怎么可能通过Handler来操作Activity中的View？）。

而Handler通常会伴随着一个耗时的后台线程（例如从网络拉取图片）一起出现，这个后台线程在任务执行完毕（例如图片下载完毕）之后，通过消息机制通知Handler，然后Handler把图片更新到界面。

然而，如果用户在网络请求过程中关闭了Activity，正常情况下，Activity不再被使用，它就有可能在GC检查时被回收掉，但由于这时线程尚未执行完，而该线程持有Handler的引用（不然它怎么发消息给Handler？），这个Handler又持有Activity的引用，就导致该Activity无法被回收（即内存泄露），直到网络请求结束（例如图片下载完毕）。另外，如果你执行了Handler的postDelayed()方法，该方法会将你的Handler装入一个Message，并把这条Message推到MessageQueue中，那么在你设定的delay到达之前，会有一条**MessageQueue -> Message -> Handler -> Activity** 的链，导致你的Activity被持有引用而无法被回收。

### 解决方式一：

**1.**在关闭Activity的时候停掉你的后台线程。线程停掉了，就相当于切断了Handler和外部连接的线，Activity自然会在合适的时候被回收。

**2.**如果你的Handler是被delay的Message持有了引用，那么使用相应的Handler的removeCallbacks()方法，把消息对象从消息队列移除就行了。

### 解决方式二：

**将Handler声明为静态类。同时将外部类用弱引用**

- **声明为静态类是因为：静态的内部类不会持有外部类的引用，所以不会持有外部类的引，所以你的Activity可以随意被回收。**
- **使用弱引用是因为需要Activity的引用而已，如果不需要调用Activity中的view什么的就不需要引用，一般都需要的所以用弱引用。**

```java
static class MyHandler extends Handler {
    WeakReference<Activity > mActivityReference;
    MyHandler(Activity activity) {
        mActivityReference= new WeakReference<Activity>(activity);
    }
 
    @Override
    public void handleMessage(Message msg) {
        final Activity activity = mActivityReference.get();
        if (activity != null) {
            mImageView.setImageBitmap(mBitmap);
        }
    }
}
```

### 解决方式三：

**不要将Handler类写为内部类，而是单独写到一个类文件中。**

- 为了让`Handler`不持有`Activity`等外部组件的实例，可以让`Handler`成为静态内部类（静态内部类是不持有外部类的实例的，因此也不能调用外部类的方法了）。因此如果要调用`Activity`中的方法就必须将外部类（`Activity`）的弱引用传递进来。申明 static 是为了解决内部类持有宿主内的引用问题，由于 `Handler` 是 static 的，为了 `Handler` 能够方便的调用 `Activity` 的方法就持有 `Activity` 的引用，并用 `WeakReference` 包裹一下。如果 `Handler` 不是以内部类的形式出现，那么 static 是不需要的。

- 在 `Activity `里的 onDestroy() 回调方法中，调用 `Handler`的`removeCallbacksAndMessages(null)`方法，清除消息队列中`Message`。

- 自定义一个LifeCycleAware的`Handler`

  ```java
  public class LifecycleHandler extends Handler implements LifecycleObserver {
  
      private LifecycleOwner lifecycleOwner;
  
      public LifecycleHandler(final LifecycleOwner lifecycleOwner) {
          this.lifecycleOwner = lifecycleOwner;
          addObserver();
      }
  
      public LifecycleHandler(final Callback callback, final LifecycleOwner lifecycleOwner) {
          super(callback);
          this.lifecycleOwner = lifecycleOwner;
          addObserver();
      }
  
      public LifecycleHandler(final Looper looper, final LifecycleOwner lifecycleOwner) {
          super(looper);
          this.lifecycleOwner = lifecycleOwner;
          addObserver();
      }
  
      public LifecycleHandler(final Looper looper, final Callback callback, final LifecycleOwner lifecycleOwner) {
          super(looper, callback);
          this.lifecycleOwner = lifecycleOwner;
          addObserver();
      }
  
      private void addObserver() {
          notNull(lifecycleOwner);
          lifecycleOwner.getLifecycle().addObserver(this);
      }
  
      @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
      private void onDestroy() {
          removeCallbacksAndMessages(null);
          lifecycleOwner.getLifecycle().removeObserver(this);
      }
  }
  ```

  

