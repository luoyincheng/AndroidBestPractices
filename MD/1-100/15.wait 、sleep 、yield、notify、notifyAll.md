> 如果线程调用了对象的wait（）方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。
>
> 当有线程调用了对象的notifyAll（）方法（唤醒所有wait线程）或notify（）方法（只随机唤醒一个wait线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。
>
> 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait（）方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了synchronized代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

---

### wait

- 该方法只有在持有了该对象的锁的线程中调用。

- 该方法永远只能在一个循环中使用。

  ```java
  synchronized (obj) {
       while (&lt;condition does not hold&gt;)
       obj.wait();
       ... // Perform action appropriate to condition
  }
  ```

---

### notify



## wait 、sleep 、yield方法的不同?

- 三者都能用来暂停当前线程。
- sleep()和yield()方法是定义在Thread类中,而wait()方法是定义在Object类中的。
- wait()和sleep()的关键的区别在于，wait()是用于线程间通信的，而sleep()是用于短时间暂停当前线程。更加明显的一个区别在于，**当一个线程调用wait()方法的时候，会释放它锁持有的锁，但是调用sleep()方法的时候不会释放锁。wait方法应在同步代码块中调用，但是sleep方法不需要。使用sleep方法时，被暂停的线程在被唤醒之后会立即进入就绪态（Runnable state)，但是使用wait方法的时候，被暂停的线程会首先获得锁（译者注：阻塞态），然后再进入就绪态。**所以，根据你的需求，如果你需要暂定你的线程一段特定的时间就使用sleep()方法，如果你想要实现线程间通信就使用wait()方法。
- **与wait()和sleep()方法有一些区别，它仅仅释放线程所占有的CPU资源，从而让其他线程有机会运行，但是并不能保证某个特定的线程能够获得CPU资源。**谁能获得CPU完全取决于调度器，在有些情况下调用yield方法的线程甚至会再次得到CPU资源。所以，依赖于yield方法是不可靠的，它只能尽力而为。
- [**wait()、notify()、notifyAll()只能在同步控制方法或者同步控制代码块中调用，而sleep()可以在非同步控制方法里调用，因为它不用操作锁。**]()
- yield()方法跟wait()方法一样也不会释放锁。
---
### 调用sleep方法后线程是否占用cpu资源？

