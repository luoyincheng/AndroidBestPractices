![](/home/yincheng/Desktop/Projects/AndroidBestPractices/app/src/main/assets/QAndA/1-100/img/tcp头.png)

TCP头部占20字节

- `ISN`(Initial Sequence Number)，初始序列号
- `ACK`：acknowledgement 确认,表示数据已经被接收方收到
- `SYN`：synchronous建立联机，发送方和接收方相互确认序号，表示连接操作。

TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据

TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如`IP`地址、端口号等。

TCP可以看成是一种字节流，它会处理`IP`层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。

TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。

---

### 三次握手

![](https://images2017.cnblogs.com/blog/985821/201708/985821-20170802101806802-1497343688.png)

> **第一次握手**：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；
> **第二次握手**：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；
> **第三次握手**：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。
> **`起初A和B都处于CLOSED状态——B创建TCB，处于LISTEN状态，等待A请求——A创建TCB，发送连接请求（SYN=1，seq=x），进入SYN-SENT状态——B收到连接请求，向A发送确认（SYN=ACK=1，确认号ack=x+1，初始序号seq=y），进入SYN-RCVD状态——A收到B的确认后，给B发出确认（ACK=1，ack=y+1，seq=x+1），A进入ESTABLISHED状态——B收到A的确认后，进入ESTABLISHED状态。`**
>
> **TCB**：传输控制块Transmission Control Block，存储每一个连接中的重要信息，如TCP连接表，到发送和接收缓存的指针，到重传队列的指针，当前的发送和接收序号。

####　为什么A还要发送一次确认呢？可以二次握手吗？

> **主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误**。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B**，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。

客户端和服务端通信前要进行连接，“3次握手”的作用就是`双方都能明确自己和对方的收、发能力是正常的`。

`第一次握手`：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

`第二次握手`：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

`第三次握手`：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。

每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？

而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。

---

### 四次挥手

假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

 ![img](https://images2017.cnblogs.com/blog/985821/201708/985821-20170802101823505-1177747613.png)

数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。（**A、B连接建立状态ESTABLISHED**——**A终止等待1状态FIN-WAIT-1**——**B关闭等待状态CLOSE-WAIT**——**A终止等待2状态FIN-WAIT-2**——**B最后确认状态LAST-ACK**——**A时间等待状态TIME-WAIT**——**B、A关闭状态CLOSED**）

- A的应用进程先向其TCP发出连接释放报文段（**FIN=1，序号seq=u**），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。

- B收到连接释放报文段后即发出确认报文段，（**ACK=1，确认号ack=u+1，序号seq=v**），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。(`**这个是来告知A,B已经收到消息了，不要让A一直发送断开连接的请求了，等B完成传输任务后，自然会像A也发出断开连接的确认信号**`)
- A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。
- 在B没有要向A发出的数据时，B发出连接释放报文段（**FIN=1，ACK=1，序号seq=w，确认号ack=u+1），**B进入LAST-ACK（最后确认）状态，等待A的确认。
- A收到B的连接释放报文段后，对此发出确认报文段（**ACK=1，seq=u+1，ack=w+1**），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。

#### 总结

起初A和B处于**ESTABLISHED状态**——A发出连接释放报文段并处于**FIN-WAIT-1状态**——B发出确认报文段且进入**CLOSE-WAIT状态**——A收到确认后，进入**FIN-WAIT-2状态**，等待B的连接释放报文段——B没有要向A发出的数据，B发出连接释放报文段且进入**LAST-ACK状态**——A发出确认报文段且进入**TIME-WAIT状态**——B收到确认报文段后进入**CLOSED状态**——A经过等待计时器时间2MSL后，进入**CLOSED状态**。

#### 为什么A在TIME-WAIT状态必须等待2MSL的时间？

- MSL：Maximum Segment Lifetime，最长报文段寿命，MSL=2

- 保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，**若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。**
- 防止“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

#### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

#### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，而从服务器发送的FIN消息到服务器收到来自客户端的ACK消息最多能耗时2MSL，就是说如果在2MSL时间内服务器没有收到最后的ACK消息，那么服务器就会重新发送FIN消息。
> **`这个2MSL是说，如果在客户端发出最终ACK以后的2MSL时间内没有收到来自服务器重新发送的FIN消息，就证明服务器收到了来自客户端的ACK。`**
>
> 现在假设服务器发送FIN到客户端用时A，客户端发送ACK到服务器用时B。
> 如果A＋B>2MSL，也就是说，服务器在发送了FIN后没有收到来自客户端的应答，这个时候服务器会重新发送FIN。此时，对于客户端来说，它发出ACK已经耗时B了,而服务器是在A+B-2MSL的时候重新发送FIN的(`**时间从0开始**`)，而这个重新发送的FIN在网络中最多也只能存活MSL，

---

### TCP服务模型

一个TCP连接由一个4元组构成，分别是两个`IP`地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。

当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。`ACK`是累积的，一个确认字节号N的`ACK`表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个`ACK`丢失，很可能后续的`ACK`就足以确认前面的报文段了。

一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种`双工服务`。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个`ACK`。

序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用`IP`来传输报文段，而`IP`不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。

---

