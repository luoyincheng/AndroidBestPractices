### 四种启动模式

- Standard:标准模式、默认模式
  Standard 模式是系统默认的启动模式，一般我们 app 中大部分页面都是由该模式的页面构成的，比较常见的场景是：社交应用中，点击查看用户A信息->查看用户A粉丝->在粉丝中挑选查看用户B信息->查看用户A粉丝... 这种情况下一般我们需要保留用户操作 Activity 栈的页面所有执行顺序。
- SingleTop:栈顶复用模式
  SingleTop 模式一般常见于社交应用中的通知栏行为功能，例如：App 用户收到几条好友请求的推送消息，需要用户点击推送通知进入到请求者个人信息页，将信息页设置为 SingleTop 模式就可以增强复用性。
- SingleTask:栈内复用模式
  SingleTask 模式一般用作应用的首页，例如浏览器主页，用户可能从多个应用启动浏览器，但主界面仅仅启动一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
- SingleInstance:全局单例模式
  SingleInstance 模式常应用于独立栈操作的应用，如闹钟的提醒页面，当你在A应用中看视频时，闹钟响了，你点击闹钟提醒通知后进入提醒详情页面，然后点击返回就再次回到A的视频页面，这样就不会过多干扰到用户先前的操作了。
---
### singleTop和singleTask的区别和应用场景

- singleTop模式的Activity会默认进入启动它所属的任务栈，即不会引起任务栈的变更，而SingleTask可以通过taskAffnity指定该Activity要进入哪个任务栈，因此可能引起任务栈的变更。
- singleTop常用于防止多次快速点击后启动多个Activity，singleTask则常用于主页和登录页。

---

### onNewIntent()

![onNewIntent](C:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\onNewIntent.png)

- 当 activity (假设为 A) 的 launchMode 为 singleTop 且 A 的实例已经在 task 栈顶，或者 launchMode 为 singleTask 且 A 的实例已在 task 栈里 (无论是栈顶还是栈中)，再次启动 activity A 时，便不会调用 onCreate() 去产生新的实例，而是调用 onNewIntent() 并重用 task 栈里的 A 实例。
- 如果 A 在栈顶，那么调用顺序依次是 A.onPause() –> A.onNewIntent() –> A.onResume()。A 的 launchMode 可以是 singleTop 或者是 singlTask。android 开发者官网 上描述的是这种情况。
- 如果 A 不在栈顶，此时它处于 A.onStop() 状态，当再次启动时，调用顺序依次是 [A.onStop()] –> A.onNewIntent() –> A.onRestart() –> A.onStart() –> A.onResume()。A 的 launchMode 只能是 singleTask。google 到的其它大多文章描述的是这种情况。

---

### startActivity()

  - Activity可以直接调用startActivity，不需要额外的设置。

- 如果从其它Context中启动Activity，且该Activity加载模式是standard或者singleTop时，就必须给intent设置Flag（singleTask和singleInstance不用设置，因为这两者在AMS中被预处理后已经隐形的设置了）:

  ```java
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK) ; 
  mContext.startActivity(intent);
  ```

  设置了该状态的intent，首先会查找是否存在和被启动的Activity具有相同的亲和性的任务栈（即taskAffinity，注意同一个应用程序中的activity的亲和性一样），如果有，刚直接把这个栈整体移动到前台（即使被启动的Activity不在栈顶，也会将该Activity上面的所有Activity也一同移动到前台，而不是让它们出栈），并保持栈中的状态不变，即栈中的activity顺序不变，如果没有，则新建一个栈来存放被启动的activity。

-  https://my.oschina.net/u/2444750/blog/605882 

---

### taskAffinity

```java
<activity
            android:name=".android_Q_A._1_100._9.TaskAffinityActivity2"
            android:launchMode="singleTask"
            android:taskAffinity="com.yincheng.taskAffinityTest" />
```

- TaskAffnity表明了该Activity希望进入的Task（Activity栈）。

- 如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，

  如果Application也没有指明，那么该taskAffinity的值就等于包名。

  而Task也有自己的affinity属性，它的值等于它的根Activity的taskAffinity的值。

>一个应用A，默认的Activity为MainActivityA，taskAffinity为`com.test.taskAffnity`，从这个MainActivityA启动了一个SecondActivityA。
>
>一个应用B，默认Activity为MainActivityB，taskAffinity为`com.test.taskAffnity`。
>
>- 先启动应用A，然后打开SecondActivityA。
>- **`此时打开应用B，看到的不是MainActivityB，而是SecondActivityA。这是因为MainActivityA重新宿主了`**但是如果将MainActivityB的launchMode改为SingleTask，这个时候看到的就是MainActivityB了，但是返回的时候发现，需要返回三次才能回到桌面。分别看到MainActivityB、SecondActivityA、MainActivityA。这就说明：在启动launchMode为SingleTask的Activity时，如果系统中已经存在跟该Activity的TaskAffnity相同的task且也存在该Activity的实例了，那么就将该task中处于该Activity实例上方的所有Activity出栈，并调用**`onNewIntent`**，如果存在TaskAffnity相同的task但是没有实例，那就实例化然后入栈，如果不存在TaskAffnity相同的task，那就重新创建Task并入栈。

>应用A有默认MainActivityA，不设置任何属性，SecondActivityA launchMode为SingleTask并且taskAffnity为``com.test.taskAffnity``，ThirdActivityC launchMode为singleInstance。
>
>应用B有默认MainActivityB，taskAffnity为`com.test.taskAffnity`，有SecondActivityB
>
>- 先启动应用B，然后启动SecondActivityB，按home键返回桌面。
>- 从MainActivityA启动SecondActivityA再启动ThirdActivityA再启动MainActivityA然后按一直按返回键。
>
>**`可以看到的顺序为：MainActivityA(5039) -> MainActivityA(5039) -> ThirdActivityA(5040) -> SecondActivityA(5038) -> SecondActivityB(5038) -> MainActivityB(5038),因为MainActivityA、SecondActivityA、ThirdActivityA都位于不同的栈中(括号后面是taskId，即当前所在的栈)`**
>
>但如果将SecondActivityA和ThirdActivityA的属性对调，SecondActivityA 的launchMode为singleInstance，而ThirdActivityA的launchMode为singleTask且taskAffnity为`com.test.taskAffnity`，这个时候按返回键可以看到：
>
>**`MainActivityA(5042) -> ThirdActivityA(5042) -> SecondActivityB(5042) -> MainActivityB(5042) -> SecondActivityA(5044) -> MainActivityA(5043)，通过taskId可以看到前四个Activity都在同一个栈中,后面两个分别在不同的栈中`**

### allowTaskReparenting

```java
<activity
            android:name=".android_Q_A._1_100._9.TaskAffinityActivity2"
            android:launchMode="singleTask"
            android:allowTaskReparenting="true"
            android:taskAffinity="com.yincheng.taskAffinityTest" />
```