<h2 style="text-align:center">为什么匿名内部类引用的参数必须用final修饰</h2>
- 除了匿名内部类内部的外部变量，方法和作用域内的内部类内部使用的外部变量也必须是`final`的
- 在java8以前的版本上需要手动添加final修饰符，java8更加只能，如果局部变量被匿名内部类访问，那么该局部变量相当于自动使用了final修饰，不需要显式的写出来，编译的结果也表名java8自动给这个局部变量添加了final修饰符。

---

### 原因

- 方法中的局部变量的生命周期很短，方法结束后变量就要被销毁，加上final是为了延长变量的生命周期。
- 内部类对象的生命周期与局部变量的生命周期不一致
- 内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。(在java中，非静态的内部类和匿名内部类都会隐式的持有一个外部类的引用)。
- 内部类并不是直接调用方法传递的参数，而是利用自身的构造器将传入的局部变量作为构造方法的参数，自己内部方法调用的实际上是自己的属性而不是外部方法传递进来的参数。
- 简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。
- **Java为了避免数据不同步的问题，做出了匿名内部类只可以访问final的局部变量的限制，因为如果Java允许匿名内部类访问非final的局部变量的话，那我们就可以在匿名内部类中修改非final的局部变量，但是这并不会对局部变量的值有影响，因为匿名内部类中改变的是匿名内部类对局部变量的那一个备份，这个备份和局部变量本身是不同的引用，如果修改后，局部变量并没有改变，这和程序的预期不一致，因此将局部变量用final来修饰，保证数据的一致性。**

---

