```
Observable
				.create(new ObservableOnSubscribe<Integer>() {
					@Override
					public void subscribe(ObservableEmitter<Integer> emitter) throws Exception {
						for (int i = 0; ; i++) {   //无限循环发事件                                              
							emitter.onNext(i);
						}
					}
				})
				.subscribeOn(Schedulers.io())
				.observeOn(AndroidSchedulers.mainThread())
				.subscribe(new Consumer<Integer>() {
					@Override
					public void accept(Integer integer) throws Exception {
						Thread.sleep(2000);
						Log.d(TAG, "" + integer);
					}
				});
```
> 无限发送事件导致占用的内存会一直飙升，直到OOM或者导致内存抖动。这是因为发送事件和接收事件处于不同的线程，发送的事件先放在缓冲中，处理事件的时候每个两秒取一个事件，双方处理速度差别太大。这是异步事件，发送不会等接收并处理，它会自顾自的不停发送。
>
> 但是如果去掉subscribeOn()和observeOn()方法，那么发送事件和接收事件将在同一个线程执行，那么实际上发送事件也会受到接收事件的影响，发送事件也是以两秒一次的速率发送的。这就是同步订阅，发送事件必须等到接收事件处理完成以后再进行下一次的发送。
>
> 因此在Log里面看到的发送和接收交替出现的大多**`同步订阅`**，如果显示发送全部打印然后是接收全部打印，一般都是**`异步订阅`**

