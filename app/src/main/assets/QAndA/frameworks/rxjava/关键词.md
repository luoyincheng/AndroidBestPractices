### 同步订阅

- 观察者和被观察者工作在同一线程。
- 被观察者发送一次事件后，必须等到观察者接收、处理后，才能继续发送下一个事件。
- **`写一个例子`**

---

### 异步订阅

- 观察者和被观察者工作在不同线程。
- 被观察者可以不断发送事件，不受观察者的影响（无论观察者是否接收、处理和事件），直到事件全部发送完毕。
- **`这种情况下，事件并不会直接发送给观察者，而是先发送到缓冲区，等观察者从缓冲区取出事件来处理，这就有可能导致OOM。`**

---

### 背压

- **`用来控制事件流速，只适用于异步订阅关系中,即观察者和被观察者工作在不同线程`**

- 解决了因被观察者发送事件速度与观察者接收事件速度 **`不匹配`**（一般是前者快于后者），从而导致观察者无法及时响应 / 处理所有被观察者发送的事件。

- 具体实现：**`Flowable`**，原理如下：

  > 1.控制观察者接收事件的速度。响应式拉取，即观察者根据自身实际情况按需接收事件。
  >2.控制被观察者发送事件的速度。反馈控制，即被观察者根据观察者的接收事件的能力来控制发送事件的速度。
  >   3.采用背压策略。对超出缓存区大小的事件进行丢弃、保留、报错的措施。

#### 策略

- **MISSING：**
  如果流的速度无法保持同步，可能会抛出MissingBackpressureException或IllegalStateException
- **BUFFER**
  上游不断的发出onNext请求，直到下游处理完，也就是和Observable一样了，缓存池无限大，最后直到程序崩溃
- **ERROR**
  会在下游跟不上速度时抛出MissingBackpressureException。
- **DROP**
  会在下游跟不上速度时把onNext的值丢弃。
- **LATEST**
  会一直保留最新的onNext的值，直到被下游消费掉。





