<h2 style=text-align:center>内存泄露</h2>
- [取消动态注册的广播]()，静态注册的广播不会泄漏，因为持有的是ApplicationContext。

  Activity中动态注册的广播接收器，一般性写法都是此Activity中持有创建的广播接收器的对象引用，并指明广播接收器对应的接收广播类型（IntentFilter）。

  Activity中调用registerReceiver(mBroadcastReceiver, intentFilter)方法进行广播接收器的注册。此时，通过Binder机制向AMS(Activity Manager Service)进行注册。

  AMS会对应的记录Activity上下文、广播接收器以及对应的IntentFilter等内容，并形成类似于消息的发布-订阅存储模式与结构。

  当对应的广播发出时，在定义的广播接收器的onReceive(context, intent)方法回调中，对于Activity中动态注册的广播接收器，onReceive方法回调中的context指的是Activity Context！

  也就是说，Activity与mBroadcastReceiver此时实际上是通过AMS相互持有强引用的。因此，对于Activity中动态注册的广播接收器，一定要在对应的声明周期回调方法中去unregisterReceiver，以斩断此关联。

  否则，就会出现当前Activity的内存泄露。

- [注销监听器]()，同上

  当我们需要使用系统服务时，比如执行某些后台任务、为硬件访问提供接口等等系统服务。我们需要将自己注册到服务的监听器中，然而，这会让服务持有Activity的引用，如果忘记Activity销毁时取消注册，就会导致Activity泄露。 

- [关闭输入输出流]()

  在使用IO、File流等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果不及时关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。 

- ContentObserver，File，Cursor，Stream，Bitmap等资源，使用后未关闭会导致内存泄漏。因为资源性对象往往都用了一些缓冲，缓冲不仅存在于 java虚拟机内，还存在于java虚拟机外。如果仅仅是把它的引用置null，而不关闭它们，也会造成内存泄漏。

- ~~[回收Bitmap]()~~

  ~~`Bitmap` 对象不在使用时调用recycle()释放内存~~（Bitmap已经不需要手动调用recycle()方法了）

- 全局集合类强引用没清理造成的内存泄漏（特别是 static 修饰的集合）

- [注销EventBus]()

- `Activity` 的 `Context` 造成的泄漏，可以使用 `ApplicationContext`

- [单例模式]()

  单例中的static成员间接或直接持有了activity的引用。

- 非静态内部类持有父类的引用，如非静态handler持有activity的引用（一般由于 `Handler` 生命周期比其外部类的生命周期长引起的）

- AsyncTask持有Activity或者Fragment的引用导致内存泄漏。

- [关闭无线循环的属性动画]()

  如果在当前 Activity 中播放此类动画，并且没有在结束的时候(onDestory)去停止该动画，那么动画会一直播放下去，尽管在界面上无法看见动画的运转，但是在此时 Activity 的 View 会被动画所持有，而 View 又持有当前 Activity，最终导致 Activity 无法被释放。 

- Dialog导致的内存泄漏。 在当前 Dialog 所依附的 Activity 销毁之前,我们没有去将当前的 Dialgo 销毁(dismiss) 话也是很容易导致内存泄漏的。 

- [RxJava中使用Observable.Interval]()发送定时任务时，如果没有在onDestroy中dispose()事件就会leak，这里是因为Observer被Observable引用，Observer中又可能持有View或者Activity等的引用。其实不止是Observable.Interval,类似的还有[Timer和TimerTask]()。



  



