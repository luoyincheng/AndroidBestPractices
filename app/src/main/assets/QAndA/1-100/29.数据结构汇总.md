|                   |     底层结构     | 是否允许空键 | 是否允许空值 | 是否线程安全 |      特点      |         容量          |
| :---------------: | :--------------: | :----------: | :----------: | :----------: | :------------: | :-------------------: |
|     ArrayList     |       数组       |      ○       |      ✔       |      否      | 查询快、增删慢 | 超过初始容量后增加50% |
|    LinkedList     |       链表       |      ○       |      ✔       |      否      | 增删快、查询慢 |           ○           |
|      Vector       |       数组       |      ○       |      ✔       |      是      | 增删慢、查询慢 |  超过初始容量后翻倍   |
|                   |                  |              |      ✘       |              |                |                       |
|      HashMap      | 数组+链表/红黑树 |  ✔（一个）   |      ✔       |      否      |                |                       |
|   LinkedHashMap   | 数组+链表/红黑树 |      ✔       |      ✔       |      否      |                |                       |
|     HashTable     | 数组+链表/红黑树 |      ✘       |      ✘       |      是      |                |                       |
| ConcurrentHashMap | 数组+链表/红黑树 |      ✘       |      ✘       |      是      |                |                       |
|    SparseArray    |                  |              |              |              |                |                       |

#### 为什么HashTable和ConcurrentHashMap不允许null作为key和value，而HashMap和LinkedHashMap却可以？

- HashMap是非并发的，ConcurrentHashmap和Hashtable都是支持并发的，这样会有一个问题，当你通过get(k)获取对应的value时，如果获取到的是null时，你无法判断，它是put（k,v）的时候value为null，还是这个key从来没有做过映射。即便此刻你通过contains(key)知晓了是否包含null，下一步当你使用这个结果去做一些事情时可能其他线程已经改变了这种状态，而这在单线程下是不可能发生的。 

  >The main reason that nulls aren't allowed in ConcurrentMaps (ConcurrentHashMaps, ConcurrentSkipListMaps) because there will be ambiguities that may be just barely tolerable in non-concurrent maps can't be accommodated.
  >
  >**`主要原因是当map.get(key)返回null时，你没法知道是这个key-value中value本身就是null还是说map中根本就没有这个key-value。`**
  >
  >在一个非并发的map中，可以通过**`map.containsKey(key)`**方法来判断，但是在并发的map中，the map might have changed between calls.
  >
  >比如下面的代码：

  ```java
  if (map.containsKey(k)) {
       return map.get(k);
  } else {
       throw new KeyNotPresentException();
  }
  ```

  >**`It might be possible that key k might be deleted in between the get(k) and containsKey(k) calls.`**
  >
  >As a result, the code will return null as opposed to KeyNotPresentException (Expected Result if key is not present).
  >
  >The Null key and value allowed in HashMap because there is no Concurrent access.