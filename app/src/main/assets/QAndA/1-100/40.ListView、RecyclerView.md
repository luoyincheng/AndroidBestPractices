### ListView

#### 如何优化

- 利用好 convertView 来重用 View，切忌每次 getView() 都新建。ListView 的核心原理就是重用 View。ListView 中有一个回收器，Item 滑出界面的时候 View 会回收到这里，需要显示新的 Item 的时候，就尽量重用回收器里面的 View。

- **`使用ViewHolder`**

  在一个已经Inflate的Layout中寻找View是Android开发中非常普遍的操作。这通常通过View的findViewById方法来实现。这个方法会递归整个View树，以寻找那个与ID匹配的View。在静态的代码中使用findViewById()还是非常棒的，但是，如你看到的那样。当滑动ListView的时候，ListView会非常频繁的回调Adapter的getView()方法。这就可能在不知不觉中影响ListView的滑动性能。尤其发生在你的Item的Layout非常的复杂的时候。

  ViewHolder就是用来存储那些在你的getView()方法中调用findViewById()方法得到的View。ViewHolder是一个非常轻巧的内部类。它存储那些Item内部的View的直接引用。然后可以在Inflate结束之后，将ViewHolder对象存储在Item的tag当中。以这种方式，你只需要在第一次创建Item的时候调用findViewById就可以了。

  下面就是使用ViewHolder提高ListView的代码：

  ```java
  
  public View getView(int position, View convertView, ViewGroup parent) {
  	ViewHolder holder;
  	if (convertView == null) {
  		convertView = mInflater.inflate(R.layout.your_layout, null);
  		holder = new ViewHolder();
  		holder.text = (TextView) convertView.findViewById(R.id.text);
  		convertView.setTag(holder);
  		} else {
  			holder = convertView.getTag();
  		}
  		holder.text.setText("Position " + position);
  		    return convertView;
  		}
  private static class ViewHolder {
  	public TextView text;
  }
  ```

- 利用好 View Type，例如你的 ListView 中有几个类型的 Item，需要给每个类型创建不同的 View，这样有利于 ListView 的回收，当然类型不能太多；

- 尽量让 ItemView 的 Layout 层次结构简单，这是所有 Layout 都必须遵循的；

- 善用自定义 View，自定义 View 可以有效的减小 Layout 的层级，而且对绘制过程可以很好的控制；

- 尽量能保证 Adapter 的 hasStableIds() 返回 true，这样在 notifyDataSetChanged() 的时候，如果 id 不变，ListView 将不会重新绘制这个 View，达到优化的目的；

- 每个 Item 不能太高，特别是不要超过屏幕的高度，可以参考 Facebook 的优化方法，把特别复杂的 Item 分解成若干小的 Item，特别推荐看一下这个文章：[https://code.facebook.com/posts/879498888759525/fast-rendering-news-feed-on-android/](https://link.zhihu.com/?target=https%3A//code.facebook.com/posts/879498888759525/fast-rendering-news-feed-on-android/)

- 为了保证 ListView 滑动的流畅性，getView() 中要做尽量少的事情，不要有耗时的操作。特别是滑动的时候不要加载图片，停下来再加载，这个库可以帮助你 Glide：[https://github.com/bumptech/glide](https://link.zhihu.com/?target=https%3A//github.com/bumptech/glide)

- 使用 RecycleView 代替。 ListView 每次更新数据都要 notifyDataSetChanged()，有些太暴力了。RecycleView 在性能和可定制性上都有很大的改善，推荐使用。

#### RecycleBin(回收站)

- 

---

### RecyclerView

```java
@NonNull
@Override 
public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
	View view = LayoutInflater.from(mContext).inflate(R.layout.item_single_text, parent);(错)
    View view = LayoutInflater.from(mContext).inflate(R.layout.item_single_text, parent,false);(对)
	return new ViewHolder(view);
}
```

> java.lang.IllegalStateException: ViewHolder views must not be attached when created. Ensure that you are not passing 'true' to the attachToRoot parameter of LayoutInflater.inflate(..., boolean attachToRoot)

#### RecyclerView不同视图类型和缓存原理

### 优化点

- [**全局使用一个onClickListener，并在ViewHolder构造函数中设置，而不是在onBindViewHolder中设置。**]()。`onCreateViewHolder()`和`onBindViewHolder()`对时间比较敏感，应尽量避免在这两个方法中执行繁琐的操作和创建对象。

  ```java
  private class XXXHolder extends RecyclerView.ViewHolder {
  		private EditText mEt;
      EditHolder(View itemView) {
          super(itemView);
          mEt = (EditText) itemView;
          mEt.setOnClickListener(mOnClickListener);
      }
  }
      
  private View.OnClickListener mOnClickListener = new View.OnClickListener() {
      @Override
      public void onClick(View v) {
          //do something
      }
  }
  ```

- [**setHasFixedSize(true)**]()。true if adapter changes cannot affect the size of the RecyclerView。在item的宽/高值固定的情况下，设置了这个以后，随着Adapter中数据的插入和删除，RecyclerView不会每次都去检查自身大小是否改变。这不是说RecyclerView的宽高就不可变了，它可能随着父View大小而变化。

  ```java
    onItemRangeChanged()
    onItemRangeInserted()
    onItemRangeRemoved()
    onItemRangeMoved()
  ```

    > 在以上四个方法中会判断mHasFixedSize变量，如果为true，就调用ViewCompat.postOnAnimation()方法，如果为false会走requestLayout()方法，这会造成极大的资源浪费。 


- [**滑动过程中停止加载图片**]()。

  > 设置`RecyclerView.addOnScrollListener();`在滑动过程中使用Glide的pauseRequests()方法来暂停获取图片。

- [**利用DiffUtil/AsyncListDiffer**]()

  **DiffUtil的作用，就是找出集合中每一个Item发生的变化，然后对每个变化给予对应的刷新。** 

  一般用于数据集更改的情况，而不是用于纯粹的数据添加的情况，比如下拉刷新。

    DiffUtil最终是调用Adapter的下面几个方法来进行局部刷新：

  ```java
  mAdapter.notifyItemRangeInserted(position, count);
  mAdapter.notifyItemRangeRemoved(position, count);
  mAdapter.notifyItemMoved(fromPosition, toPosition);
  mAdapter.notifyItemRangeChanged(position, count, payload);
  ```

  > 使用DiffUtil时，Adapter中的setData()方法或者构造器中设置数据时需要使用：this.mData = new ArrayList<>(data);使得外部和内部使用的是不同的数据引用，这样在外部重新设置数据时不会直接对内部数据进行更改。
  >
  > areItemTheSame()方法用来判断是不是同一个item。
  >
  > areContentsTheSame()在areItemTheSame()返回true才会调用。
  >
  > getChangePayload()方法中，payload是一个用来描述item变化的对象，也就是item发生了哪些变化，这些变化封装成了一个payload，一般用Bundle来充当。这个方法在areItemsTheSame()方法返回true而areContentsTheSame返回false时调用的。在RecyclerView.Adapter中有两个onBindViewHolder方法，一个是我们必须要重写的，而另一个的第三个参数就是一个payload的列表。
  >
  > DiffUtil的calculateDiff()方法是执行在主线程的，这个方法的耗时取决于 the number of changes in the list  and the cost of your comparison methods ，**`因此如果耗时较长需要开启子线程执行。或者直接使用AsyncListDiffer。`**


- [**加大RecyclerView的缓存，用空间换时间，来提高滚动的流畅性。**]()

  ```java
  recyclerView.setItemViewCacheSize(20);
  recyclerView.setDrawingCacheEnabled(true);
  recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);
  ```

- [**使用calculateExtraLayoutSpace()为LinearLayoutManager设置更多的预留空间**]()

  todo

- [**共用RecycledViewPool**]()

  在嵌套RecyclerView中，如果子RecyclerView具有相同的adapter，那么可以设置 **`RecyclerView.setRecycledViewPool(pool)`**来共用一个RecycledViewPool。 

   如果LayoutManager是LinearLayoutManager或其子类，需要手动开启这个特性：`layout.setRecycleChildrenOnDetach(true)` 

  ```
  class OuterAdapter extends RecyclerView.Adapter<OuterAdapter.ViewHolder> {
      RecyclerView.RecycledViewPool mSharedPool = new RecyclerView.RecycledViewPool();
  ...
  
      @Override
      public OuterAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
          RecyclerView innerLLM = new RecyclerView(inflater.getContext());
          LinearLayoutManager innerLLM = new LinearLayoutManager(parent.getContext(), LinearLayoutManager.HORIZONTAL);
          innerLLM.setRecycleChildrenOnDetach(true);
          innerRv.setLayoutManager(innerLLM);
          innerRv.setRecycledViewPool(mSharedPool);
          return new OuterAdapter.ViewHolder(innerRv);
      }
  ```

- [**RecyclerView数据预取(prefetch功能)**]()

  todo

- [**处理刷新闪烁**]()

  > 调用notifyDataSetChange时，适配器不知道整个数据集中的那些内容以及存在，再重新匹配ViewHolder时会花生闪烁。
  > 设置adapter.setHasStableIds(true)，并重写getItemId()来给每个Item一个唯一的ID

- 减少过度绘制

      减少布局层级，可以考虑使用自定义View来减少层级，或者更合理的设置布局来减少层级。 

- 减少xml文件inflate时间

      xml文件包括：layout、drawable的xml，xml文件inflate出ItemView是通过耗时的IO操作。可以使用代码去生成布局，即`new View()`的方式。这种方式是比较麻烦，但是在布局太过复杂，或对性能要求比较高的时候可以使用。

- 减少View对象的创建

      一个稍微复杂的 Item 会包含大量的 View，而大量的 View 的创建也会消耗大量时间，所以要尽可能简化 ItemView；设计 ItemType 时，对多 ViewType 能够共用的部分尽量设计成自定义 View，减少 View 的构造和嵌套。

- 回收资源

  通过重写`RecyclerView.onViewRecycled(holder)`来回收资源。 

### 区别

-  ListView采用的是RecyclerBin的回收机制在一些轻量级的List显示时效率更高。

### 

