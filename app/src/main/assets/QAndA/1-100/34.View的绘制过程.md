```java
void scheduleTraversals() {
    if (!mTraversalScheduled) {
        mTraversalScheduled = true;
        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
        //第二个参数
        mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        if (!mUnbufferedInputDispatch) {
            scheduleConsumeBatchedInput();
        }
        notifyRendererOfFramePending();
        pokeDrawLockIfNeeded();
    }
}
```

```java
final class TraversalRunnable implements Runnable {
    @Override
    public void run() {
        doTraversal();
    }
}
```

```java
    void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }
			//最终的绘制开始的地方
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }
```

```java
private void performTraversals() {
}
```



- View的绘制是由ViewRoot来完成的。
  每个应用程序窗口的decorView都有一个与之关联的ViewRoot对象，这种关联关系是由WindowManager来维护的。在ActivityThread中，当Activity对象被创建完毕之后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联。这些都是在**`handleResumeActivity`**方法中进行的。
  
  ```java
  @Override
      public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,
              String reason) {
          if (r.window == null && !a.mFinished && willBeVisible) {
              r.window = r.activity.getWindow(); //获取window,到这里Activity已经设置了window了。
              View decor = r.window.getDecorView();//获取DecorView
              decor.setVisibility(View.INVISIBLE);
              ViewManager wm = a.getWindowManager();//获取WindowManager。
              WindowManager.LayoutParams l = r.window.getAttributes();
              a.mDecor = decor;//给Activity设置DecorView
              l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
              l.softInputMode |= forwardBit;
              if (r.mPreserveWindow) {
                  a.mWindowAdded = true;
                  r.mPreserveWindow = false;
                  ViewRootImpl impl = decor.getViewRootImpl();
                  if (impl != null) {
                      impl.notifyChildRebuilt();
                  }
              }
              if (a.mVisibleFromClient) {
                  if (!a.mWindowAdded) {
                      a.mWindowAdded = true;
                      wm.addView(decor, l);//通过WindowManager将DecorView添加到Activity中
                  } else {
                      a.onWindowAttributesChanged(l);
                  }
              }
          } else if (!willBeVisible) {
              if (localLOGV) Slog.v(TAG, "Launch " + r + " mStartedActivity set");
              r.hideForNow = true;
          }
      }
  ```
  
  
  
- ActivityThread中有一个Handler用于对Activity的管理比如：

  > CREATE_SERVICE、BIND_SERVICE、UNBIND_SERVICE、CONFIGURATION_CHANGED、LOW_MEMORY、DUMP_HEAP、SLEEPING、RECEIVER等**`我猜这个方法是由系统服务(AMS之类的)发送给它的`**

- 




## 测量 -> 布局 -> 绘制

- 每个Activity都会创建一个PhoneWindow，phoneWindow是Activity和View系统交互的接口。每个Window在创建后也会创建一个关联这个Window的WindowManager.
- DecorView继承自FrameLayout，是Activity中所有View的祖先。
- ViewRoot不是一个View，是一个对DecorView的管理者。它将DecorView和PhoneWindow组合起来。
-  ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。ViewRoot里面有一个ViewRootHandler类，用于事件分发。
- 在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联 。
- **绘制会从根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。**
- ViewRootImpl中setView会设置一个根View。因此ViewRoot包含一个根View对象。
- DecorView里面包含一个竖直方向的LinearLayout， **上面是个ViewStub,延迟加载的视图（应该是设置ActionBar,根据Theme设置），中间的是标题栏(根据Theme设置，有的布局没有)，下面的是内容栏，（setContentView就是给这里设置的）** 。
- 

### 对象之间的关系

- DecorView和PhonwWindow相互持有，DecorView会attach到PhoneWindow上， Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。 
- PhoneWindow也有一个DecorView

### 真是哪儿都有Handler

- ActivityThread
- ViewRoot
- 


<h1 style="text-align:center">测量</h1>
## MeasureSpec

- MeasureSpec是一个32位整型值，由模式(Mode)和大小(Size)组合而成。高两位是Mode，后30位是Size，`这样做减小了对象的分配开支`。

- MeasureSpec是父View传递给子View的，是用父View的MeasureSpec和子View的布局参数LayoutParams，共同计算出子View的MeasureSpec。

- 三种模式：

  > **UPSPECIFIED** : 父容器对于子容器没有任何限制,子容器想要多大就多大
  > **EXACTLY**:  父容器已经检测出 View 所需要的精确大小，这个时候 View 的最终大小就是 MeasureSpec所指定的值，它对应于 LayoutParams 的 match_parent 和具体的数值两种模式 
  > **AT_MOST**： 父容器指定一个大小即 SpecSize，View 的大小不能大于这个值，具体是什么值要看不同View 的具体实现，它对应于 LayoutParams 的wrap_content。 

- **DecorView的MeasureSpec由窗口的尺寸和其自身的 LayoutParams 来共同决定 ， 对于普通的 View，其 MeasureSpec 由父容器的 MeasureSpec 和 自身的 LayoutParams 决定，MeasureSpec 一旦确定后，onMeasure 中就可以确定 View 的测量宽高。 **

  对于DecorView：

  在ViewRootImpl中有：

  ```java
  private static int getRootMeasureSpec(int windowSize, int rootDimension) {
          int measureSpec;
          switch (rootDimension) {
  
          case ViewGroup.LayoutParams.MATCH_PARENT:
              // Window can't resize. Force root view to be windowSize.
              measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
              break;
          case ViewGroup.LayoutParams.WRAP_CONTENT:
              // Window can resize. Set max size for root view.
              measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
              break;
          default:
              // Window wants to be an exact size. Force root view to be that size.
              measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
              break;
          }
          return measureSpec;
      }
  ```

  

  对于普通的View：

  ViewGroup中的measureChild()方法：

  ```java
  protected void measureChild(View child, int parentWidthMeasureSpec,
              int parentHeightMeasureSpec) {
          final LayoutParams lp = child.getLayoutParams();
  
          final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                  mPaddingLeft + mPaddingRight, lp.width);
          final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                  mPaddingTop + mPaddingBottom, lp.height);
  
          child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
      }
  ```

  总共九种情况：

  > public static final int MATCH_PARENT = -1;
  > public static final int WRAP_CONTENT = -2;
  
  ```java
  public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
          int specMode = MeasureSpec.getMode(spec);
          int specSize = MeasureSpec.getSize(spec);
  
          int size = Math.max(0, specSize - padding);
  
          int resultSize = 0;
          int resultMode = 0;
  
          switch (specMode) {
          // Parent has imposed an exact size on us
          case MeasureSpec.EXACTLY:
              if (childDimension >= 0) {
                  resultSize = childDimension;
                  resultMode = MeasureSpec.EXACTLY;
              } else if (childDimension == LayoutParams.MATCH_PARENT) {
                  // Child wants to be our size. So be it.
                  resultSize = size;
                  resultMode = MeasureSpec.EXACTLY;
              } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                  // Child wants to determine its own size. It can't be
                  // bigger than us.
                  resultSize = size;
                  resultMode = MeasureSpec.AT_MOST;
              }
              break;
  
          // Parent has imposed a maximum size on us
          case MeasureSpec.AT_MOST:
              if (childDimension >= 0) {
                  // Child wants a specific size... so be it
                  resultSize = childDimension;
                  resultMode = MeasureSpec.EXACTLY;
              } else if (childDimension == LayoutParams.MATCH_PARENT) {
                  // Child wants to be our size, but our size is not fixed.
                  // Constrain child to not be bigger than us.
                  resultSize = size;
                  resultMode = MeasureSpec.AT_MOST;
              } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                  // Child wants to determine its own size. It can't be
                  // bigger than us.
                  resultSize = size;
                  resultMode = MeasureSpec.AT_MOST;
              }
              break;
  
          // Parent asked to see how big we want to be
          case MeasureSpec.UNSPECIFIED:
              if (childDimension >= 0) {
                  // Child wants a specific size... let him have it
                  resultSize = childDimension;
                  resultMode = MeasureSpec.EXACTLY;
              } else if (childDimension == LayoutParams.MATCH_PARENT) {
                  // Child wants to be our size... find out how big it should
                  // be
                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                  resultMode = MeasureSpec.UNSPECIFIED;
              } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                  // Child wants to determine its own size.... find out how
                  // big it should be
                  resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                  resultMode = MeasureSpec.UNSPECIFIED;
              }
              break;
          }
          //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
      }
  ```
```
  
**总结**
  
  ![](C:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\ModeSpec.jpg)
  
  - 当 View 采用固定宽高的时候，不管父容器的 MeasureSpec 是什么，View 的 MeasureSpec 都是精确模式并且大小遵循 LayoutParams 中的大小。
  - 当 View 中的宽高是 match_parent 时，如果父容器的模式是精准模式，那么 View 也是精准模式，其大小是父容器的剩余空间，如果父容器是最大模式，那么 View 也是最大模式但大小不会超过父容器的剩余空间。
  - 当 View 的宽高是 wrap_content 时，不管父容器的模式是精准还是最大模式， View 的模式总是最大模式但大小不会超过父容器的剩余空间。





### 绘制的整体流程

- 绘制从ViewRootImpl的performTraversals()方法开始（这个方法800行）。在这个方法里面分别执行了

  ```java
  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);//测量
  performLayout(lp, mWidth, mHeight);//布局
  performDraw();//绘制
```