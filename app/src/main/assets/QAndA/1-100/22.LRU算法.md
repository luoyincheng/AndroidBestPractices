<h2 style="text-align:center">LRU算法</h2>
https://blog.csdn.net/qq_15893929/article/details/85229364



### 用LinkedHashMap的一个简单实现

```java
public SimpleCache(int limit) {
	super(limit, 0.75f, true);//第三个参数表明使用访问顺序
	this.limit = limit;
}
```

```java
//返回值表示如果超过最大限制数量的情况下是否将最旧的数据删除
@Override
protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
	return size() > limit;
}
```

### LRU

---

### DiskLRUCache 

##### 各个参数的意义

|          参数           |                             作用                             |
| :---------------------: | :----------------------------------------------------------: |
|       lruEntries        |                    缓存实体在内存中的表示                    |
|         journal         |                    缓存实体在日志中的表示                    |
|       valueCount        | 每个key可以对应的缓存文件的数量（比如对于图片来说，可以有原图、缩略图、处理后的图等等？） |
| long[] lengths(entry中) | 这个lengths的length就是由valueCount决定的，每个key对应的所有values(可能有多个)占用的磁盘空间都写在lengths中 |
|     executorService     | 只有一个线程的线程池，专门负责清理工作。会清除过多的缓存和根据lruEntries生成新的Journal日志 |
|  cleanFile和dirtyFile   | 当取操作的时候读取的是CleanFile，而写操作是先写到DirtyFIle，再重命名为CleanFile。这样就算写失败了，至少还有CleanFile。 |
|      readJournal()      |      读取每一行的JournalFile的记录，转换到lruEntries中       |
|    processJournal()     |    负责将清除掉journalFileTmp中间文件，清除掉不一致的记录    |

##### entry和editor的关系？

- 两者相互持有对方的

##### LRU（最近最少使用）是如何得到保证的？

```java
/**
 * Constructs an empty <tt>LinkedHashMap</tt> instance with the
 * specified initial capacity, load factor and ordering mode.
 *
 * @param  initialCapacity the initial capacity
 * @param  loadFactor      the load factor
 * @param  accessOrder     the ordering mode - <tt>true</tt> for
 *         access-order, <tt>false</tt> for insertion-order
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */
private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
```

- 第三个参数access-order定义了迭代器的遍历顺序，若为true，则使用访问顺序（LRU），若为false，则使用插入顺序。该属性是final类型的常量，只能赋值一次。

- 每次使用get()方法获取一个元素的时候，该元素也会被放到LinkedHashMap最后，这也是LRU在LinkedHashMap中的核心实现。

---