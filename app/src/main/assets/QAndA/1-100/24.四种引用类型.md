<h2 style="text-align:center">软引用和弱引用区别</h2>
**`一个对象可以有多个引用与之关联，比如同时有两个强引用和一个弱引用总共三个引用与之关联`**

### 引用队列



---

### 强引用

- 如果一个对象具有强引用，那垃圾回收器绝不会回收它（不会被`GC`）。当内存空间不足，Java虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。  

- 如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。

  ``` java
  //将对象的引用显式地置为`null`
  Object o=new Object();
  o = null;// Let gc do its work 
  ```
---
### 弱引用

- 只具有弱引用的对象拥有更短暂的生命周期（**`没有其它引用与它关联了`**）。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

---
### 软引用

- 对于软引用关联着的对象，只有在内存不足的时候`JVM`才会回收该对象。因此，这一点可以很好地用来解决`OOM`的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。

- 软引用可以和一个引用队列（`ReferenceQueue`）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

---
### 虚引用

- 如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。 
- 虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之 关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动 
- 一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被`GC`时收到系统通知，JAVA中用`PhantomReference`来实现虚引用。

---

### 区别

| 引用类型 | `GC`回收时间 |          用途          |    生存时间     |
| :------: | :----------: | :--------------------: | :-------------: |
|  强引用  |    never     |     对象的一般状态     | `JVM`停止运行时 |
|  弱引用  |  **`GC`**时  |        对象缓存        | **`GC`**后终止  |
|  软引用  |  内存不足时  |        对象缓存        | 内存不足时终止  |
|  虚引用  |   unknown    | 获取**`GC`**时候的通知 |     unknown     |

---

### 弱引用和软引用的使用场景区别？

- 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。

- 可以根据对象是否经常使用来判断。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。