<h2 style="text-align:center">`Map`、`HashMap`、`LinkedHashMap`、`HashTable`</h2>
### 基础

#### `Entry`

![](C:\projects\TinyTank\app\src\main\assets\QAndA\1-100\img\map中的entry体系.jpg)



- TreeNode对象的大小大约是普通Node对象大小的两倍。
- 在数据量比较小的时候(对于每个链表来说，而不是整个Map的capacity)都是使用链表。只有当一个链表太长导致查找困难时才会用红黑树代替。当该红黑树被删掉一些数据而导致数据量变得比较少时，红黑树又会转化为链表。
- HashMap中的Node.next是用于链接链表/红黑树的(数组长度是多少最多就有多少链表/红黑树)，而LinkedHashMap中的Entry.before和Entry.after是用来链接LinkedHashMap中的所有元素的。**访问顺序改变的就是LinkedHashMap.Entry.before和LinkedHashMap.Entry.after属性，而不是HashMap.Node.next属性

### Q&A

- HashMap中一般以什么类型的元素作为key？为什么？

  > 使用String或者Integer这样。
  >
  > 这些类是Immutable(不可变)的，因为都是final类型的，并且这些类已经很规范的覆写了hashCode()以及equals()方法。作为不可变类天生是线程安全的，而且可以很好的优化比如可以缓存hash值，避免重复计算等。



---

### Map



### HashMap

![](C:\projects\TinyTank\app\src\main\assets\QAndA\1-100\img\hashmap数据结构.jpg)

- 数组+链表

- HashMap的键key 可为null（区别于 HashTable的key 不可为null）

- HashMap的键key 可为null且只能为1个，而且是放在数组中第一个位置的，但值value可为null且为多个。

- threadhold = capaity * loadfactor

- 在 HashMap中，equals() 方法只有在哈希码碰撞时才会被用到。

- 比较key是否相同，只有hash值相等并且key也相等才能说明两个key完全相同。

  ```java
  // == 在在基础类型中用于比较数值是否相等，在类中比较内存地址是否相等，equals用于比较内容是否相等
  if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) 
  ```
  
- 在get()和put()中查找数组下标用的是`(tab.size - 1) & hash`，而在判断resize()时候用`tab.size & hash`判断是将当前Node放在旧位置还是新位置。

- resize()方法会将在前index的链表分成两个链表，一个放在`原index`，一个放在`(原index+oldCap)位置`。

- 当HashMap中链表的数量超过8的以后，链表就被转为红黑树了。从而将查找的复杂度从O(N)降到了O(lgN)。

#### 源码实现

- put()

  ```java
  public V put(K key, V value) {
      return putVal(hash(key), key, value, false, true);//第三个参数，false，有旧值就替换。
  }
  // @param onlyIfAbsent if true, don't change existing value
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                     boolean evict) {
          Node<K,V>[] tab; Node<K,V> p; int n, i;
          if ((tab = table) == null || (n = tab.length) == 0)
              n = (tab = resize()).length;
          if ((p = tab[i = (n - 1) & hash]) == null)    //根据hash值计算出(取模运算)该Val应该存到数组的哪个位置(下标)
              tab[i] = newNode(hash, key, value, null); //如果在数组的这个位置还不存在Node，那就将它作为链表的头节点或者树的头
          else {  //Node已经存在了
              Node<K,V> e; K k; //e代表已经存在的跟key值完全相同的Node，就是该key之前已经插入过元素了
              //为什么需要判断p.hash == hash，因为走到这证明该index在当前数组中已经存在node了，但是这个index是经过取模运算得到的，不是说到了这个位置hash值就相等
              //只能说明hash值的低位相等，高位差了大了
              //哈希值相等且key也相等证明已经存在该key了，需要覆盖
              if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) //hash值相等并且(key地址相同或者key相等)
                  e = p;
              else if (p instanceof TreeNode)//Node类型为TreeNode
                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
              else { //Node类型为链表中的Node
                  for (int binCount = 0; ; ++binCount) {
                      if ((e = p.next) == null) {//如果下一个为空了，说明到了链表末尾，直接将新Node链接到末尾就行了。
                          p.next = newNode(hash, key, value, null);
                          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                              treeifyBin(tab, hash);
                          break;
                      }
                      // 判断链表中下一个节点的key是否跟要插入的key完全相同，如果相同就啥也不做
                      if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                          break;
                      // 判断链表中下一个节点的key是否跟要插入的key完全相同，如果不同就将该节点赋值给p，继续找下一个
                      p = e;
                  }
              }
              if (e != null) { // e代表exist,存在的Node，走到这里说明该HashMap中已经存在该key了，需要更新value。
                  V oldValue = e.value;
                  if (!onlyIfAbsent || oldValue == null)
                      e.value = value;
                  afterNodeAccess(e);
                  return oldValue;
              }
        }
          ++modCount;
          if (++size > threshold)
              resize();
          afterNodeInsertion(evict);
          return null;
      }
  ```
  
- get()

  ```java
  public V get(Object key) {
      Node<K,V> e;
      return (e = getNode(hash(key), key)) == null ? null : e.value;
  }
  
  final Node<K,V> getNode(int hash, Object key) {
      Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
      if ((tab = table) != null && (n = tab.length) > 0 &&
          (first = tab[(n - 1) & hash]) != null) {//数组不为空，且数组length大于0，且计算得到的index在数组中不为空的(链表的头节点或者treeNode的rootNode不为空)
          if (first.hash == hash && // always check first node
              ((k = first.key) == key || (key != null && key.equals(k))))//判断根Node的key和要获取的元素的key是否完全相同
              return first;
          if ((e = first.next) != null) {
              if (first instanceof TreeNode)
                  return ((TreeNode<K,V>)first).getTreeNode(hash, key);
              do { //这里 因为第一次走到这里e肯定不为空，所以用do...while...
                  if (e.hash == hash &&
                      ((k = e.key) == key || (key != null && key.equals(k))))
                      return e;
              } while ((e = e.next) != null);
          }
      }
      return null;
  }
  ```

- resize()

  > 当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize
  >
  > 因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。
  >
  > 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示：
  >
  > ![](c:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\hashmap.resize.png)
  >
  > 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：
  >
  > ![](c:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\hashmap.resize1.png)
  >
  > 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。
  >
  > 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。**源码中用`(headNode.hash & oldCap) == 0`来判断的，如果是0代表高一位也为0，那么这个Node就不用动，否则就将它放到(原位置+oldCap)的位置上去。**
  >
  > ![](c:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\hasnmap.resize.final.png)

  ```java
  // 首先计算正确的capacity和threadhold，三级判断
  //然后进行移动操作
  final Node<K,V>[] resize() {
      Node<K,V>[] oldTab = table;
      int oldCap = (oldTab == null) ? 0 : oldTab.length;
      int oldThr = threshold;
      int newCap, newThr = 0;
      if (oldCap > 0) {//表明已经初始化过了
          if (oldCap >= MAXIMUM_CAPACITY) {
              threshold = Integer.MAX_VALUE;
              return oldTab;
          }
          else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                   oldCap >= DEFAULT_INITIAL_CAPACITY)
              newThr = oldThr << 1; // double threshold，将capacity和threadhold都扩大到之前的两倍。
      }else if (oldThr > 0) // initial capacity was placed in threshold，还未初始化，使用oldThread作为初始值
          newCap = oldThr;
      else {               // zero initial threshold signifies using defaults 还未初始化，使用默认的值来生成hashmap
          newCap = DEFAULT_INITIAL_CAPACITY;
          newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
      }
      if (newThr == 0) {
          float ft = (float)newCap * loadFactor;
          newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                    (int)ft : Integer.MAX_VALUE);
      }
      threshold = newThr;
      @SuppressWarnings({"rawtypes","unchecked"})
          Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
      table = newTab;
      if (oldTab != null) {
          for (int j = 0; j < oldCap; ++j) {
              Node<K,V> e;
              if ((e = oldTab[j]) != null) {//头节点存在
                  oldTab[j] = null;
                  if (e.next == null)//如果该位置只有一个Node，直接将它放到新位置就完事了。
                      newTab[e.hash & (newCap - 1)] = e;
                  else if (e instanceof TreeNode)
                      ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                  else { // preserve order，这会将原来在该index的链表分成两个链表分别存放到新的数组中去
                      Node<K,V> loHead = null, loTail = null;//原索引存放的链表的头和尾
                      Node<K,V> hiHead = null, hiTail = null;//新索引存放的链表的头和尾
                      Node<K,V> next;
                      do {
                          next = e.next;
                          if ((e.hash & oldCap) == 0) {//原索引
                              if (loTail == null)
                                  loHead = e;
                              else
                                  loTail.next = e;
                              loTail = e;
                          }
                          else {// 原索引+oldCap
                              if (hiTail == null)
                                  hiHead = e;
                              else
                                  hiTail.next = e;
                              hiTail = e;
                          }
                      } while ((e = next) != null);
                      if (loTail != null) {// 原索引放到bucket里
                          loTail.next = null;
                          newTab[j] = loHead;
                      }
                      if (hiTail != null) {// 原索引+oldCap放到bucket里
                          hiTail.next = null;
                          newTab[j + oldCap] = hiHead;
                      }
                  }
              }
          }
      }
      return newTab;
  }
  ```

- 

#### 如何将HashMap变成线程安全的呢

Map newMap = collections.synchronizedHashMap(HashMap hashMap);
#### 碰撞处理



#### 为什么需要扰动函数？以及为什么HashMap数组的长度必须是2的整次幂？

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

> 可以看到hash函数的实现是使高16bit不变，低16bit和高16bit做了一个异或
> 这样可以降低碰撞概率
>
> `key.hashCode()`生成的是一个int数，考虑到2进制32位带符号的int表值范围从**-2147483648**到**2147483648**。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。
>
> 但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个**indexFor( )**函数里完成的。
>
> ```java
> bucketIndex = indexFor(hash, table.length);
> ```
>
> indexFor的代码也很简单，就是把散列值和数组长度做一个**"与"**操作，
>
> ```java
> static int indexFor(int h, int length) {
>  return h & (length-1);
> }
> ```
>
> 这也正好解释了为什么HashMap的数组长度要取2的整次幂。因为这样（数组长度-1）正好相当于一个“**低位掩码”。**与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是**00000000 00000000 00001111**。和某散列值做“与”操作如下，结果就是截取了最低的四位值。****
>
> ```
>     10100101 11000100 00100101
> &	00000000 00000000 00001111
> ----------------------------------
> 	00000000 00000000 00000101    //高位全部归零，只保留末四位
> ```
>
> 但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。这时候“**扰动函数**”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图：
>
> ![](c:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\hashmap.hash.jpg)
>
> 右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了**混合原始哈希码的高位和低位，以此来加大低位的随机性**。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来。
>
> https://www.hollischuang.com/archives/2091

[https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/](https://yikun.github.io/2015/04/01/Java-HashMap工作原理及实现/)

---

### LinkedHashMap

![](C:\projects\TinyTank\app\src\main\assets\QAndA\1-100\img\linkedHashmap数据结构.jpg)

#### `添加`

LinkedHashMap没有复写HashMap中的put()方法，而是直接调用了HashMap的实现。但是LinkedHashMap复写了newNode()方法，在这个方法中，LinkedHashMap 创建了 Entry，并通过 linkNodeLast 方法将 Entry 接在双向链表的尾部，实现了双向链表的建立。

```java
  Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {//e:next
      LinkedHashMapEntry<K,V> p = new LinkedHashMapEntry<K,V>(hash, key, value, e);
      linkNodeLast(p);
      return p;
  }
```

```java
  private void linkNodeLast(LinkedHashMapEntry<K,V> p) {
      LinkedHashMapEntry<K,V> last = tail;
      tail = p;
      if (last == null)
          head = p;
      else {
          p.before = last;
          last.after = p;
      }
  }
```

#### `删除`

与插入操作一样，LinkedHashMap 删除操作相关的代码也是直接用父类的实现。在删除节点时，父类的删除逻辑并不会修复 LinkedHashMap 所维护的双向链表，这不是它的职责。

在HashMap的removeNode()方法中，删除完一个元素后最终会调用方法afterNodeRemoval(),可以在这里进行元素的unlink操作。

```java
//这个方法是复写HashMap中的，因此传入的参数是HashMap.Node类型
//但是在LinkedHashMap中已经在所有用到HashMap.Node的地方都将它转为了LinkedHashMapEntry,，因此实际上这里传入的是LinkedHashMapEntry,因此可以强转。详见代码_146
void afterNodeRemoval(Node<K,V> e) { // unlink
    LinkedHashMapEntry<K,V> p =
        (LinkedHashMapEntry<K,V>)e, b = p.before, a = p.after;//
    p.before = p.after = null;
    if (b == null)
        head = a;
    else
        b.after = a;
    if (a == null)
        tail = b;
    else
        a.before = b;
}
```



#### `访问顺序的维护过程`

```java
/**
 * Constructs an empty <tt>LinkedHashMap</tt> instance with the
 * specified initial capacity, load factor and ordering mode.
 *
 * @param  initialCapacity the initial capacity
 * @param  loadFactor      the load factor
 * @param  accessOrder     the ordering mode - <tt>true</tt> for
 *         access-order, <tt>false</tt> for insertion-order
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */
private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
```

- 第三个参数access-order定义了迭代器的遍历顺序，若为true，则使用访问顺序（LRU），若为false，则使用插入顺序。该属性是final类型的常量，只能赋值一次。

- 访问顺序的原理上并不复杂，当我们调用`get/getOrDefault`方法时，只需要将这些方法访问的节点移动到链表的尾部即可，每次使用get()方法获取一个元素的时候，该元素也会被放到LinkedHashMap最后，这也是LRU在LinkedHashMap中的核心实现。

- **访问顺序改变的是LinkedHashMap.Entry.before和LinkedHashMap.Entry.after属性，而不是HashMap.Node.next属性。**

  前后变化如图所示：

  ![](C:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\linkedhashmap.access.pre.jpg)

  ![](C:\Projects\TinyTank\app\src\main\assets\QAndA\1-100\img\linkedhashmap.access.after.jpg)

  源码如下：

  ```java
   public V get(Object key) {
      Node<K,V> e;
      if ((e = getNode(hash(key), key)) == null)
          return null;
      if (accessOrder)
          afterNodeAccess(e);
      return e.value;
  }
  ```

  ```java
  void afterNodeAccess(Node<K,V> e) { // move node to last
      LinkedHashMapEntry<K,V> last;
      if (accessOrder && (last = tail) != e) {
          LinkedHashMapEntry<K,V> p =
              (LinkedHashMapEntry<K,V>)e, b = p.before, a = p.after;
          p.after = null;
          if (b == null)
              head = a;
          else
              b.after = a;
          if (a != null)
              a.before = b;
          else
              last = b;
          if (last == null)
              head = p;
          else {
              p.before = last;
              last.after = p;
          }
          tail = p;
          ++modCount;
      }
  }
  ```

  https://segmentfault.com/a/1190000012964859

---

### HashTable

### ConcurrentHashMap

#### `sizeCtl变量`

- ```java
  private transient volatile int sizeCtl;
  ```

- sizeCtl是一个用来同步多个线程的共享变量

- 如果它的当前值为负数，则说明table正在被某个线程初始化或者扩容。

- 如果某个线程想要初始化table或者对table扩容，需要去竞争sizeCtl这个共享变量，获得变量的线程才有许可去进行接下来的操作，没能获得的线程将会一直自旋来尝试获得这个共享变量。

- 获得sizeCtl这个变量的线程在完成工作之后需要设置回来，使得其他的线程可以走出自旋进行接下来的操作。

- 当线程发现sizeCtl小于0的时候，他就会让出CPU时间，而稍后再进行尝试，当发现sizeCtl不再小于0的时候，就会通过调用方法compareAndSwapInt来将sizeCtl共享变量变为-1，以告诉其他试图获得sizeCtl变量的线程，目前正在由本线程在享用该变量，在我完成我的任务之前你可以先休息一会，等会再来试试吧，我完成工作之后会释放掉的。而其他的线程在发现sizeCtl小于0的时候就会理解这种交流，他们会让出cpu时间，等待下次调度再来尝试获取sizeCtl来进行自己的工作。在完成初始化table的任务之后，线程需要将sizeCtl设置成可以使得其他线程获得变量的状态，这其中还有一个地方需要注意，就是在某个线程通过U.compareAndSwapInt方法设置了sizeCtl之前和之后进行了两次check，来检测table是否被初始化过了，这种检测是必须的，因为在并发环境下，可能前一个线程正在初始化table但是还没有成功初始化，也就是table依然还为null，而有一个线程发现table为null他就会进行竞争sizeCtl以进行table初始化，但是当前线程在完成初始化之后，那个试图初始化table的线程获得了sizeCtl，但是此时table已经被初始化了，所以，如果没有再次判断的话，可能会将之后进行put操作的线程的更新覆盖掉，这是极为不安全的行为。 

#### `initTable()`

- compareAndSwapInt()方法请参考unsafe.md

- ```java
  private final Node<K,V>[] initTable() {
          Node<K,V>[] tab; int sc;
          while ((tab = table) == null || tab.length == 0) {
              if ((sc = sizeCtl) < 0) //说明其它线程正在初始化
                  Thread.yield(); // lost initialization race; just spin
              //判断SIZECTL位置的数值和sc是否相等，如果相等就将这个位置的值替换成-1，返回true。实际上就是将sizeCtl的值替换。只不过是从内存地址中取值的。
              //如果不相等，就什么也不做，返回false。
              //就是说这个方法就是判断内存中的sizeCtl是否变了，只是为了保证操作过程的原子性而已。
              else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {//将sizeCtl改成-1
                  try {
                      if ((tab = table) == null || tab.length == 0) {
                          int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                          @SuppressWarnings("unchecked")
                          Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                          table = tab = nt;
                          sc = n - (n >>> 2);
                      }
                  } finally {
                      sizeCtl = sc;//初始化后，sizeCtl长度为数组长度的3/4
                  }
                  break;
              }
          }
          return tab;
      }
  ```

- 








